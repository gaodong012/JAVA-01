##1.堆内存
依据对象的存活周期（有的对象存活周期短，有的对象存活周期长），划分堆空间为年轻代、老年代，年轻代中又划分为Eden区和两个survial区

##2.堆内存与GC策略
之所以需要进行GC的根本原因就是内存是有限的，GC主要有三种方式
标记-复制、标记-清除-整理、标记-清除。都是由GC root对象开始标记。针对不同的堆分区采用不同的GC策略，由于不管采用哪种GC都有STW，会导致应用工作的暂停，对延迟时间和吞吐量会造成影响，GC调优其实就是对STW和回收的频率做调整，达到性能的平衡。对young区一般都采用标记-复制策略，将存活的对象复制到存活区中，对老年代一般采用标记-清除-整理的方式，但是由于整理会消耗资源，可能导致STW的时间有些长，这时候有些GC策略就会对此进行优化，例如CMOS GC通过并发的策略，使单次GC的STW降低。

##3.SerialGC
串行化GC，采用一个线程做GC,GC时STW，效率比较低

##4.ParallelGC
并行化GC,采用多个线程同时做GC,GC的效率是所有策略中最高的，吞吐量要求高的系统可以采用此GC策略，但是延迟要求高的系统可能不适用。

##5.CMOSGC
并行化GC,初始标记、标记预处理等阶段的时候，GC线程与应用线程同时都在工作，只有最终标记和收集的时候才STW，这样STW的时间就会比较短，但是并发的GC线程会与应用程序线程争抢资源，导致吞吐量上比不上并行GC,注意并发GC针对的老年代的回收策略，年轻代还是采用标记复制的并行GC策略。

##6.G1 GC
G1在CMOS上进一步做了优化，将堆内存划分成一个个的region小区，region有时候是eden区，有时候又是存活区，有时候又是老年代的区，而且对老年代的回收设置阈值，默认为45%，总体原理与CMOS比较相似，G1可以做到比较低的延迟，但是当触发fullGC的时候，G1会退化成串行化GC,导致比较长的STW，因此G1在内存比较大的时候表现更好，一般要求8G以上，最好16G以上。